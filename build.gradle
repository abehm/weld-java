apply plugin: 'scala'
apply plugin: 'maven-publish'

version = '0.1.0'
group = "weld"

repositories {
    jcenter()
    mavenCentral()
}

dependencies {
    compile 'org.scala-lang:scala-library:2.11.8'
    compile 'org.scijava:native-lib-loader:2.1.5'
    testImplementation 'junit:junit:4.12'
}

/**
 * Configure the build script dependencies so we can use the NativeLibraryUtil to determine the
 * location of the locally built native library.
 */
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath group: 'org.scijava', name: 'native-lib-loader', version: '2.1.5'
    }
}

/**
 * Generate the JNI headers for java integration.
 */
task generateJniHeaders(type:Exec) {
    def classpath = sourceSets.main.scala.outputDir
    def nativeIncludes = "src/native/include"
    commandLine "javah", "-d", nativeIncludes, "-classpath", classpath, "weld.WeldJNI\$"
    dependsOn classes
}

/**
 * Compile the weld-java native library.
 *
 * In the future we might want to get (mac/linux) cross compilation working. The easiest solution
 * seems to be use something like travis or appveyor for this. Another somewhat harder solution is
 * to use Docker. There are a few flavors here:
 * - Use cross (https://github.com/japaric/cross), although that does not explicitly support mac
 *   (and other ties 1 platforms).
 * - Create our own linux image that supports cross compilation for mac using osxcross.
 *
 * I have tried to use the rust's x86_64-unkown-musl target but that only supports static
 * libraries which does not work with JNI. We should revisit this when it supports dynamic
 * libraries. See https://chr4.org/blog/2017/03/15/cross-compile-and-link-a-static-binary-on-macos-for-linux-with-cargo-and-rust/
 * for more information on this, and be sure to set the CC & AR environment vars in order to
 * compile backtrace.
 */
task compileWeld(type:Exec) {
    commandLine "cargo", "build", "--release"
}

test {
    dependsOn cleanTest
    testLogging.showStandardStreams = true
    systemProperty 'java.library.path', 'target/release/'
}

jar {
    manifest {
        attributes('Implementation-Title': project.name,
                   'Implementation-Version': project.version)
    }
    // Make sure we copy the compiled native libary to the correct location in the jar file.
    def platform = org.scijava.nativelib.NativeLibraryUtil.getArchitecture().name().toLowerCase()
    def libname = org.scijava.nativelib.NativeLibraryUtil.getPlatformLibraryName('weld_java')
    into('META-INF/lib/' + platform) {
      from {
        'target/release/' + libname
      }
    }
    dependsOn compileWeld
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
}
