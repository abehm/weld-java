import org.scijava.nativelib.NativeLibraryUtil

apply plugin: 'scala'
apply plugin: 'maven-publish'

version = '0.1.0-SNAPSHOT'
group = "weld"

repositories {
    jcenter()
    mavenCentral()
}

dependencies {
    compile 'org.scala-lang:scala-library:2.11.8'
    compile 'org.scijava:native-lib-loader:2.1.5'
    testImplementation 'junit:junit:4.12'
}

/**
 * Configure the build script dependencies so we can use the NativeLibraryUtil to determine the
 * location of the locally built native library.
 */
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath group: 'org.scijava', name: 'native-lib-loader', version: '2.1.5'
    }
}

/**
 * Generate the JNI headers for java integration.
 */
task generateJniHeaders(type:Exec) {
    def classpath = sourceSets.main.scala.outputDir
    def nativeIncludes = "src/native/include"
    commandLine "javah", "-d", nativeIncludes, "-classpath", classpath, "weld.WeldJNI\$"
    dependsOn classes
}

/**
 * Compile the weld-java native library.
 *
 * We currently support compilation for the local platform and provide a docker image for linux
 * compilation. You can build weld-java for linux using the docker linux image by executing the
 * `compileWeldLinux` task. Note that building the linux library is not super fast, and that this
 * should be reserved for release builds.
 *
 * There is also an image that should be able to build weld-java for both linux and mac. You can
 * find its Dockerfile in the `docker/cross` directory. This is however a work in progress and it
 * is currently not able to build its mac target; it fails with various linker errors.
 *
 * A different solution to cross compilation would be use something like travis of appveyor to
 * do for us.
 *
 * I have tried to use the rust's x86_64-unkown-musl target but that only supports static
 * libraries which does not work with JNI. We should revisit this when it supports dynamic
 * libraries. See https://chr4.org/blog/2017/03/15/cross-compile-and-link-a-static-binary-on-macos-for-linux-with-cargo-and-rust/
 * for more information on this, and be sure to set the CC & AR environment vars in order to
 * compile backtrace.
 */
task compileWeld(type:Exec) {
    commandLine "cargo", "build", "--release"
}

task compileWeldLinux(type:Exec) {
    def dir = rootProject.projectDir.toString()
    // Build the docker image. This will take some time on the first run.
    commandLine "docker", "build", "-t", "weld-java-linux", "docker/linux"
    // Build the weld-java native library for linux.
    commandLine "docker", "run", "--rm", "-v", dir + ":/source", "weld-java-linux",
                "cargo", "build", "--release", "--target=x86_64-unknown-linux-gnu"
}

test {
    dependsOn cleanTest
    testLogging.showStandardStreams = true
    systemProperty 'java.library.path', 'target/release/'
}

jar {
    manifest {
        attributes('Implementation-Title': project.name,
                   'Implementation-Version': project.version)
    }
    // Make sure we copy the compiled native libary to the correct location in the jar file.
    def platform = NativeLibraryUtil.getArchitecture().name().toLowerCase()
    def libname = NativeLibraryUtil.getPlatformLibraryName('weld_java')
    into('META-INF/lib/' + platform) {
      from {
        'target/release/' + libname
      }
    }
    // Attempt to copy native libraries for the various platforms to the jar.
    into('META-INF/lib/osx_64') {
        from {
            'target/x86_64-apple-darwin/release/libweld_java.dylib'
        }
    }
    into('META-INF/lib/linux_64') {
        from {
            'target/x86_64-unknown-linux-gnu/release/libweld_java.so'
        }
    }
    dependsOn compileWeld
    mustRunAfter compileWeldLinux
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
    repositories {
        def target = version.contains('SNAPSHOT') ? 'snapshot' : 'release'
        maven {
            url "$rootProject.projectDir/../repo/$target"
        }
    }
}
